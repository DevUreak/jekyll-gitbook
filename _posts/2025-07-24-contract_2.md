---
title: Solidity-Array expolit
author: Tao He
date: 2025-07-24
category: Jekyll
layout: post
---

- 이 섹션에서는 실험을 통해 얻은 내용들을 서술한다.

Unchecked Issue
-------------
Array에서 underflow expolit attack은 

0.5.0 이하 버전에서 `array.length —-;` 를 통해서 길이를 줄일수있다 그리고 underflow 를 이용하여 특정 메모리 슬롯을 이용하여 조작이 가능해진다.
0.8.0 부터는 불가능하지만 **unchecked 블록안에서는 아직도 가능하니 주의해야한다.**
<br>
먼저 배열의 저장방식을 이해해야한다.
- 배열이나 매핑형태는 Slot 0 ..1 ..2 ..3 순차적으로 저장하는 방식이아니다
    ![img]({{ site.baseurl }}/assets/array1.png){: style="width:500px;","display: block; margin: 0;" }
    
- 먼저 슬롯은 0 부터 2^256 - 1 개의 데이터를 저장할수있는 공간을 가지고있다.
- 배열처럼 순차적으로 접근해서 저장한다고 생각하면된다.
- 그렇다면 배열은 어떻게 저장하는가?

```
// 아래와 같은 데이터구조를 가지고있다고 하자
contract StorageTest {
    uint256 a;
    uint256[2] b;

    struct Entry {
        uint256 id;
        uint256 value;
    }
    Entry c;
    Entry[] d;
}
```

- Slot 0 : uint256 a 가 저장된다
- Slot 1 : uint256[0] b 가 저장
- Slot 2 : uint256[1] b 가 저장
    - 여기서 중요한건 배열의 저장방식은 동적배열과 정적 배열의 저장방식과는 다르다는것이다.
    - 여기서 정적배열은 저장할 데이터 갯수를 알수있기 때문에 바로 슬롯에 데이터를 할당하여 저장하는 방식을 사용한다.
- Slot 3 : Entry 객체의 구조체 데이터가 저장된다 (c)  해당 객체는 uint256 id, uint256 value 두가지 형태의 데이터를 가지고있기 때문에 slot3 , slot4 에 각각 데이터가 순차적으로 저장된다 (위에서 아래로)
- Slot 4 : c.value 가 저장된다.
- Slot 5 : **d 동적 배열의 사이즈가 계속 저장된다.**
    - 여기서 재밌는점은 동적 배열을 저장할때는 스토리지가 두번일어난다는거다.
    - 그 이유는 길이를 바꿔줘야하는것과, 데이터를 저장하는것 두가지가 일어나기 때문이다.

- 그렇다면 우리는 이제 동적 배열이 어느 위치에 저장되는건지를 알아봐야한다.
    - 동적 배열에서 데이터의 저장 위치는 아래와 같이 저장된다.
    ```
    // 배열의 접근 Index
    (uint256(keccak256(slotNumber)) + index ) * dataSize
    ```
    - uint256 tmp[];
    - tmp[0] = 10;
    - 위와 같은 데이터를 저장, tmp의 slot 0이라고 가정하겠다
    - `(uint256(keccak256(0)) + 0) * 1`  —> 이때 dataSize는 256데이터 사이즈당 1 이다
    - 위의 위치에서 데이터가 저장된다.
  
- 그렇다면 어떻게 공격해야할까?
- 일단 언플로우와 오버프롤우 모두 필요하다.
- 먼저 조작할 배열에 언더플로우를 만들어서 배열의 길이를 max로 만들어준다.
- 그다음에 저장할 데이터의 위치를 오버플로우를 내서 0위치에서 우리가 지정된위치에 데이터를 작성할수있게 만들어야한다.
- 우리는 배열에 데이터저장 위치를 아래와 같이 계산한다고 하였다. 그리고 이부분에 저장한다고 했다.
- 이 부분을 살펴보면 슬롯이 1 이라는기준으로 어떠한 데이터도 없다고 가정하겠다.
    ```
    (uint256(keccak256(slotNumber)) + index ) * dataSize
    ```
- 그렇다면  EVM 에서 먼저 고정적으로 수행되는것은 slotNumber를 이용해서 이부분을 계산하는것이다. 예를들어 uint256(keccak256(slot)) 이값이 100이라 치면  (100 + 0) * 1 이렇게 저장된다 (dastaSize는 1 이라고 가정)
- 여기서 동적으로 계산되는값은 바로 0 이부분이다. 우리가 어떠한 인덱스에  저장하고싶은지에 따라서 계산 결과는 달라진다.
- 그래서 이부분을 오버 플로우를 만들어낼려면 어떻게해야할까?  11543212491.. 이 max 값이 위치를 계산할때 발생해야한다.
- 100 + index  = 11543212491.. 이 되어야한다.   index = 11543212491.. - 100 이 된다.  솔리디티 코드로 옮겨 보면
    ```
    index = ((2 ** 256) - 1) - uint256(keccak256(slot))
    ```
- 이렇게 계산된다
- 이 값은 앞서 길이를 언더플로우를 만들었으니 가능한 값이다. 이렇게 입력된 값은 MAX값을 만든다.
- 여기서 끝나는게 아니고 사실 한가지 더있다.
- 오버플로우를 시켜야한다는것, +1  이상의 값을 넣어줘야한다.
    ```
    index = ((2 ** 256) - 1) - uint256(keccak256(slot)) + 1
    ```
- 그렇다 우리는 이제 slot에 접근할수있게 된거다..
- +1 을 하면 slot 0 에 접근
- +2 를 하면 slot 1 에 접근 가능해진거다.
- 근데 이문제는 사라진 문제가아닌가? 아니다.
- **unchecked 를 사용해서 배열을 다루는 경우 이 해당 이슈는 발생하고 적용된다.**